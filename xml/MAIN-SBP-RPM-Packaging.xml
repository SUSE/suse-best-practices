<?xml version="1.0" encoding="UTF-8"?>
<!--<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng" type="xml"?>-->
<!DOCTYPE article [
<!ENTITY % entity SYSTEM "entity-decl.ent">
%entity;
]>
<article role="sbp" xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="art-sbp-rpm-packaging"
    xml:lang="en">
    <info>
        <title>Introduction to RPM Packaging</title>
        <subtitle/>
        <!--<orgname>SUSE Best Practices</orgname>-->
        <productname>SUSE Linux Enterprise, openSUSE</productname>
        <productnumber/>
        <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
            <dm:bugtracker>
                <dm:url>https://github.com/SUSE/suse-best-practices/issues/new</dm:url>
                <dm:product>Introduction to RPM Packaging</dm:product>
            </dm:bugtracker>
            <dm:editurl>https://github.com/SUSE/suse-best-practices/edit/main/xml/</dm:editurl>
        </dm:docmanager>
        
        
        
            <meta name="series">SUSE Best Practices</meta> 
            <meta name="category">Packaging</meta> 
            
            <meta name="platform">SUSE Linux Enterprise</meta>    
            <meta name="platform">openSUSE</meta>        
            
            <authorgroup>
            <author>
            <personname>
            <firstname>Duncan</firstname>
                <surname>Mac-Vicar Prett</surname>
            </personname>
            <affiliation>
                <jobtitle>Director Data Center Management</jobtitle>
            <orgname>SUSE</orgname>
            </affiliation>
            </author>
         <!--   <author>
            <personname>
            <firstname></firstname>
            <surname></surname>
            </personname>
            <affiliation>
            <jobtitle></jobtitle>
            <orgname></orgname>
            </affiliation>
            </author>
            <editor>
            <orgname></orgname>
            </editor>
            <othercredit>
            <orgname></orgname>
            </othercredit>-->
            </authorgroup>
        
        <cover role="logos">
            <mediaobject>
                <imageobject>
                    <imagedata fileref="suse.svg" width="4em"/>
                </imageobject>
            </mediaobject>
         <!--   <mediaobject>
                <imageobject>
                    <imagedata fileref="microsoft.svg" width="6em"/>
                </imageobject>
            </mediaobject>-->
        </cover>
  
        <date>May 29, 2017</date>

        <abstract>
            <para>In general, a pre-built, open source application is called a <emphasis
                    role="italic">package</emphasis> and bundles all the binary, data, and
                configuration files required to run the application. A package also includes all the
                steps required to deploy the application on a system, typically in the form of a
                script. The script might generate data, start and stop system services, or
                manipulate files and directories. A script might also perform operations to upgrade
                existing software to a new version.</para>

            <para>Because each operating system has its idiosyncrasies, a package is typically
                tailored to a specific system. Moreover, each operating system provides its own
                    <emphasis role="italic">package manager</emphasis>, a special utility to add and
                remove packages from the system. SUSE-based systems – openSUSE and SUSE Linux
                Enterprise - use the RPM Package Manager. The package manager precludes partial and
                faulty installations and <quote>uninstalls</quote> by adding and removing the files
                in a package atomically. The package manager also maintains a manifest of all
                packages installed on the system and can validate the existence of prerequisites and
                co-requisites beforehand. </para>

            <para>This document describes in detail how to create an RPM package on SUSE-based
            systems. </para>
            
            <para>
                <emphasis role="strong">Disclaimer: </emphasis>
                Documents published as part of the SUSE Best Practices series have been contributed voluntarily
                by SUSE employees and third parties. They are meant to serve as examples of how particular
                actions can be performed. They have been compiled with utmost attention to detail. However,
                this does not guarantee complete accuracy. SUSE cannot verify that actions described in these
                documents do what is claimed or whether actions described have unintended consequences.
                SUSE LLC, its affiliates, the authors, and the translators may not be held liable for possible errors
                or the consequences thereof.
            </para>
            
        </abstract>
    </info>

    <sect1 xml:id="sec-package">
        <title>What Is a Package</title>

        <para>A package is a way of distributing software on Linux systems. A single application is
            distributed as one or more packages. Usually the main package contains the program, and
            in addition some optional or secondary packages.</para>
        <para>On some platforms, applications are self-contained into a directory. This means
            installing an application is simply adding a directory, and uninstalling the application
            is simply removing this directory.</para>
        <para>Linux systems tend to share as much of their components as possible. Partly this is the case
            because of some advantages of this philosophy. But mainly it happens because of the fact
            that in the Linux ecosystem, the whole universe is built by the same entity, except for
            a few 3rd party applications. This makes it easy to assume that a library is available
            for all applications to consume. </para>
        <para>In a MacOS system, only the core comes from a single vendor, and all applications are
            provided by third party suppliers. It is therefore harder to make assumptions, and they
            tend to ship their own version of any depending component, with the exception of
            everything being documented as the <quote>platform</quote>.</para>

        <sect2 xml:id="sec-anatomy">
            <title>Anatomy of a Package</title>

            <para>As an example, we start with a well-known UNIX tool: rsync.</para>
            <para>A package is an archive file:</para>
            <screen>rsync-3.1.2-1.5.x86_64.rpm</screen>
            <para>This archive file contains all files related to the application:</para>

            <screen>$ rpm -qpl rsync-3.1.2-1.5.x86_64.rpm

/etc/logrotate.d/rsync
/etc/rsyncd.conf
/etc/rsyncd.secrets
/etc/sysconfig/SuSEfirewall2.d/services/rsync-server
/etc/xinetd.d/rsync
/usr/bin/rsync
/usr/bin/rsyncstats
/usr/lib/systemd/system/rsyncd.service
/usr/sbin/rcrsyncd
/usr/sbin/rsyncd
/usr/share/doc/packages/rsync
/usr/share/doc/packages/rsync/COPYING
/usr/share/doc/packages/rsync/NEWS
/usr/share/doc/packages/rsync/README
/usr/share/doc/packages/rsync/tech_report.tex
/usr/share/man/man1/rsync.1.gz
/usr/share/man/man5/rsyncd.conf.5.gz</screen>

            <para>Additionally, it contains some extra metadata. This metadata should include but it
                is not limited to:</para>

            <orderedlist>
                <listitem>
                    <para>Name</para>
                </listitem>
                <listitem>
                    <para>Summary</para>
                </listitem>
                <listitem>
                    <para>Description</para>
                </listitem>
                <listitem>
                    <para>License</para>
                </listitem>
                <listitem>
                    <para>etc.</para>
                </listitem>
            </orderedlist>

            <para>As an example, the metadata for <command>rsync</command> look as
                follows:</para>

            <screen>$ rpm -qpi rsync-3.1.2-1.5.x86_64.rpm

Name        : rsync
Version     : 3.1.2
Release     : 1.5
Architecture: x86_64
Install Date: Wed 26 Oct 2016 01:31:12 PM CEST
Group       : Productivity/Networking/Other
Size        : 636561
License     : GPL-3.0+
Signature   : RSA/SHA256, Mon 17 Oct 2016 02:32:40 AM CEST, Key ID b88b2fd43dbdc284
Source RPM  : rsync-3.1.2-1.5.src.rpm
Build Date  : Mon 17 Oct 2016 02:32:26 AM CEST
Build Host  : lamb18
Relocations : (not relocatable)
Packager    : http://bugs.opensuse.org
Vendor      : openSUSE
URL         : http://rsync.samba.org/
Summary     : Versatile tool for fast incremental file transfer
Description :
Rsync is a fast and extraordinarily versatile file  copying  tool. It can copy
locally, to/from another host over any remote shell, or to/from a remote rsync
daemon. It offers a large number of options that control every aspect of its
behavior and permit very flexible specification of the set of files to be
copied. It is famous for its delta-transfer algorithm, which reduces the amount
of data sent over the network by sending only the differences between the
source files and the existing files in the destination. Rsync is widely used
for backups and mirroring and as an improved copy command for everyday use.
Distribution: openSUSE Tumbleweed</screen>

            <para>To get a list of additional packages which the respective package requires to be
                installed to work, use the command <command>Requires</command> as shown
                below:</para>

            <screen>$ rpm -qp --requires rsync-3.1.2-1.5.x86_64.rpm
/bin/sh
/usr/bin/perl
config(rsync) = 3.1.2-1.5
coreutils
diffutils
fillup
grep
libacl.so.1()(64bit)
libacl.so.1(ACL_1.0)(64bit)
libc.so.6()(64bit)
libc.so.6(GLIBC_2.10)(64bit)
libc.so.6(GLIBC_2.14)(64bit)
libc.so.6(GLIBC_2.15)(64bit)
libc.so.6(GLIBC_2.2.5)(64bit)
libc.so.6(GLIBC_2.3)(64bit)
libc.so.6(GLIBC_2.3.4)(64bit)
libc.so.6(GLIBC_2.4)(64bit)
libc.so.6(GLIBC_2.6)(64bit)
libc.so.6(GLIBC_2.7)(64bit)
libc.so.6(GLIBC_2.8)(64bit)
libpopt.so.0()(64bit)
libpopt.so.0(LIBPOPT_0)(64bit)
libslp.so.1()(64bit)
rpmlib(CompressedFileNames) &lt;= 3.0.4-1
rpmlib(PayloadFilesHavePrefix) &lt;= 4.0-1
rpmlib(PayloadIsLzma) &lt;= 4.4.6-1
sed
systemd</screen>

            <para>As an example, a package may need a library, or an executable that is called
                during runtime.</para>
            <para>To get a list of information the respective package provides for other packages to
                work, use the command <command>Provides</command> as shown below:</para>

            <screen>$ rpm -qp --provides rsync-3.1.2-1.5.x86_64.rpm
config(rsync) = 3.1.2-1.5
rsync = 3.1.2-1.5
rsync(x86-64) = 3.1.2-1.5</screen>
        </sect2>

        <sect2 xml:id="sec-installing-packages">
            <title>Installing Packages</title>

            <para>When a package is installed, the content (or list of files) is placed on the
                system at the location of each file path relative to the root
                    (<filename>/</filename>) directory. </para>
            <para>Additionally, the metadata of the package (and the fact that it is installed) is
                recorded in a system-wide database located in <filename>/var/lib/rpm</filename>.
                This is managed by the <command>rpm</command> tool, the utility that manages
                packages at the lowest level.</para>
            <para>Packages can be installed with the <command>rpm</command> tools:</para>

            <screen>$ rpm -U rsync-3.1.2-1.5.x86_64.rpm</screen>

            <para>When you do this, you can perform the same queries without specifying the
                    <command>-p</command> option and using what is called the NVRA
                (name-version-release-architecture, <package>rsync-3.1.2-1.5.x86_64</package>) or a
                subset of it, for example, just the name (<package>rsync</package>). </para>

            <screen>$ rpm -q --provides rsync</screen>

            <para>The <command>rpm</command> tool will not help you if the dependencies of
                the package are not met at installation time. It will then refuse to install the
                package to avoid having the system in an inconsistent state.</para>
            <para>Features like automatically finding the required packages and retrieving them, are
                implemented in higher-level tools like <command>zypper</command>.</para>
        </sect2>

        <sect2 xml:id="sec-dependency">
            <title>Dependency Matching</title>

            <para>The section <xref linkend="sec-anatomy"/> explains that a package contains a list
                of <command>Requires</command> and <command>Provides</command>. Those are not
                package names, but arbitrary symbols. A package can require or provide any string of
                text. </para>

            <para>The main rule is that each package provides its own name. This means the rsync
                package <command>Provides: rsync</command>.</para>
            <para>You have also learned that rsync requires <package>/bin/sh</package>. While this
                looks like a file name, in our context it is an arbitrary symbol and the meaning is
                given by the whole distribution. The reason why it does not require a package named
                    <package>sh</package> instead is that it provides a layer of indirection that
                makes the system cohesive. </para>

            <para><package>/bin/sh</package> is a capability provided by the <package>bash</package>
                package. This allows rsync to depend on any shell implementation as long as it
                provides that symbol. </para>

            <para>The distribution build system will scan all executables a package installs in a
                system and inject automatically those <command>Provides</command>. The packager does
                not need to take care of them.</para>

            <para>The same is done with libraries. As an example, <package>rsync</package> does not
                depend on the <package>glibc</package> package. When <package>glibc</package> was
                built, the build system scanned the content, found
                    <package>/lib64/libc.so.6</package> and injected a <command>Provides:
                    libc.so.6()(64bit)</command> into the <package>glibc</package> metadata. In the
                case of shared libraries it is not so important where they are located, because the
                linker configuration takes care of that. When the <package>rsync</package> package
                was built (<package>glibc</package> needed to be installed at that point to build
                it), the build system scanned the executable <filename>/usr/lib/rsync</filename> and
                realized it was linked against <package>libc.so.6</package>:</para>

            <screen>$ ldd /usr/bin/rsync
        linux-vdso.so.1 (0x00007ffccb34a000)
        libacl.so.1 => /lib64/libacl.so.1 (0x00007fc406028000)
        libpopt.so.0 => /usr/lib64/libpopt.so.0 (0x00007fc405e1b000)
        libslp.so.1 => /usr/lib64/libslp.so.1 (0x00007fc405c02000)
        libc.so.6 => /lib64/libc.so.6 (0x00007fc405863000)
        libattr.so.1 => /lib64/libattr.so.1 (0x00007fc40565e000)
        libcrypto.so.1.0.0 => /lib64/libcrypto.so.1.0.0 (0x00007fc4051c4000)
        libpthread.so.0 => /lib64/libpthread.so.0 (0x00007fc404fa7000)
        /lib64/ld-linux-x86-64.so.2 (0x00005653cd048000)
        libdl.so.2 => /lib64/libdl.so.2 (0x00007fc404da3000)
        libz.so.1 => /lib64/libz.so.1 (0x00007fc404b8d000)</screen>

            <para>Therefore, it injected Requires: libc.so.6()(64bit) to the rsync package.</para>
            <para>Now compare it to other packaging systems. The package
                    <package>musicplayer</package> requires <package>libsound</package>.
                    <filename>/usr/bin/musicplayer</filename> links to
                    <filename>/usr/lib64/libsound.so.5</filename>. At a later point in time,
                    <package>musicplayer</package> is rebuilt against a newer
                    <package>libsound</package>, which is not published. The user installs
                    <package>musicplayer</package> without any issue because it only
                    <command>Requires: libsound</command> (as in the package name). However, when
                the user tries to run it, he or she gets the following message:</para>

            <screen>$ musicplayer
error while loading shared libraries: libsound.so.7: cannot open shared object file: No such file or directory</screen>

            <para>The layer of indirection of automatically injected dependencies prevents this
                manual work from keeping dependencies in synchronization. Packages only provide what
                they really carry (because provides are injected by advanced scanners). Packages
                only require what they really need (because requires are injected by scanning
                executables, scripts for shebangs, etc.).</para>

            <para>This allows rpm based distributions to use these conventions highly cohesive. It
                makes upgrades less problematic and the danger of breaking your system nearly
                non-existent. At the same time, the conventions and indirections between <emphasis
                    role="strong">Provides</emphasis> and <emphasis role="strong"
                    >Requires</emphasis> allow for packages to depend on more abstract capabilities,
                instead of specific package names (which sometimes get renamed, split, obsoleted,
                etc). For example, you can be sure the <package>vim</package> package provides
                    <package>vi</package>.</para>
            <para>There are also other dependencies with more advances purposes:
                    <command>Conflicts</command>, <command>Obsoletes</command>, etc. Their names let
                you easily understand what purposes they have.</para>
        </sect2>

        <sect2 xml:id="sec-weak-dependencies">
            <title>Weak Dependencies</title>
            <para>Not everything is as strict as you might think. Sometimes a package works better
                if another package is present. Sometimes a package enhances the functionality of
                another package, however in neither case they are required. For this purpose,
                packages can have the following dependencies:</para>

            <itemizedlist>
                <listitem>
                    <para><command>Recommends</command>: a soft version of requires. If the
                        recommended packages are not installed, the package will be installed
                        anyway. Higher level tools however may pull automatically recommended
                        packages based on user settings.</para>
                </listitem>
                <listitem>
                    <para>The reverse of this dependency is <command>Supplements</command>. For
                        example a package <package>spellchecker</package> could
                            <command>Supplements</command> an <package>office-suite</package>
                        package.</para>
                </listitem>
                <listitem>
                    <para><command>Suggests</command> and <command>Enhances</command>:the forward
                        and backward version of Recommends and Supplements in a weaker
                        version.</para>
                </listitem>
            </itemizedlist>
        </sect2>

    </sect1>
    <sect1 xml:id="sec-working-packages">
        <title>Working with Packages</title>

        <para>For daily system administration and maintenance, the <command>rpm</command>
            tool does not suffice. You will quickly fall into what is commonly called the
            “dependency hell”. This means you download packages manually to quickly satisfy a
            dependency, but then you realize the new package implicates another dependency.</para>
        <para>This problem is taken care of by a tool that implements a solver. The solver
            considers: </para>

        <itemizedlist>
            <listitem>
                <para>The list of installed packages (and therefore all its dependencies)</para>
            </listitem>
            <listitem>
                <para>The list of available packages</para>
            </listitem>
            <listitem>
                <para>The user request (<quote>install package foo</quote>, <quote>upgrade
                        system</quote>)</para>
            </listitem>
        </itemizedlist>

        <para>The solver performs an operation that finds the best solution to a problem that has
            many solutions. Therefore “best” is defined by policies, user settings, the distribution
            itself, etc. </para>
        <para>On SUSE systems, the solver is implemented by the <emphasis role="strong"
                >libsolv</emphasis> /> project (see more at <link
                xlink:href="https://github.com/openSUSE/libsolv"/>. This engine implements both a
            satisfiability algorithm and an efficient way to represent the problem in memory.
            Originally it was developed by Michael Schroeder at SUSE, but today it powers also other
            distribution package managers, such as Fedora’s <command>dnf</command>.</para>
        <para>The rest of the package manager includes:</para>

        <itemizedlist>
            <listitem>
                <para>Handling of package repositories</para>
            </listitem>
            <listitem>
                <para>Checking the integrity of packages</para>
            </listitem>
            <listitem>
                <para>Fetching remote packages</para>
            </listitem>
            <listitem>
                <para>Reading and honoring user/system policies</para>
            </listitem>
        </itemizedlist>

        <para>In SUSE systems, this functionality is implemented by the <emphasis role="strong"
                >ZYpp</emphasis> (see <link xlink:href="https://en.opensuse.org/Portal:Libzypp"
            />)library, which also includes a command-line tool called
                <command>zypper</command>. While tools like <emphasis role="strong"
                >YaST</emphasis> (see <link xlink:href="https://yast.github.io/"/>) also interact
            with <emphasis role="strong">ZYpp</emphasis>, on the console you will likely interact
            with <command>zypper</command>. The command </para>

        <screen>$ zypper install rsync-3.1.2-1.5.x86_64.rpm</screen>

        <para>will, unlike rpm, check what else your system is missing, retrieve it, and then
            install all the required packages in the right order. It will also warn you if another
            package conflicts with what you are installing, or if the operation has more than one
            solution, and ask you for your decision what to do.</para>
        <para>But from where does the system <quote>retrieve other packages</quote>?</para>

        <sect2 xml:id="sec-repositories">
            <title>Repositories</title>

            <para>zypper can install a package directly from an rpm file. If there is the need for
                installing dependencies or retrieving packages – for example when you upgrade a
                system - you will need a “library” of packages. This is what is called a repository.
                A repository is:</para>

            <itemizedlist>
                <listitem>
                    <para>A collection of packages</para>
                </listitem>
                <listitem>
                    <para>A set of metadata files</para>
                </listitem>
            </itemizedlist>

            <para>The metadata is nothing more than the information present in the rpm file (Name,
                Description, Dependencies). The metadata allows the package manager to operate with
                the repository without having stored all rpm files locally. Every operation that is
                processed uses the given information of the package, and then the rpm files are
                retrieved on demand at installation time.</para>

            <screen>$ zypper lr

# | Alias          | Name           | Enabled | GPG Check | Refresh
--+----------------+----------------+---------+-----------+--------
1 | non-oss        | NON-OSS        | Yes     | ( p) Yes  | Yes
2 | oss            | OSS            | Yes     | ( p) Yes  | Yes
3 | oss-update     | OSS Update     | Yes     | ( p) Yes  | Yes
4 | update-non-oss | Update Non-Oss | Yes     | ( p) Yes  | Yes</screen>

            <para>A system normally will have the following repositories:</para>

            <itemizedlist>
                <listitem>
                    <para>The base repository, which contains all the distribution packages </para>
                </listitem>
                <listitem>
                    <para>Additional modules, add-on products or extensions</para>
                </listitem>
                <listitem>
                    <para>An update repository for each base product or extension </para>
                </listitem>
            </itemizedlist>

            <para>Running list repositories with <command>-u</command> will display the URI of the
                repository:</para>

            <screen>zypper lr -u
            http://download.opensuse.org/update/leap/42.2/oss/.</screen>

            <para>If you visit the URI, you will see:</para>

            <itemizedlist>
                <listitem>
                    <para>a <filename>x86_64</filename> directory containing all
                        architecture-dependent packages (this means ones that contain executables,
                        shared libraries, etc)</para>
                </listitem>
                <listitem>
                    <para>a <filename>noarch</filename> directory containing
                        architecture-independent packages (this means ones containing data or
                        scripts)</para>
                </listitem>
                <listitem>
                    <para>a <filename>repodata</filename> directory, containing the metadata for all
                        packages </para>
                </listitem>
            </itemizedlist>

            <para>The metadata for this type of repositories consists in a
                    <filename>repodata/repomd.xml</filename> file index, which is signed
                    (<filename>repomd.xml.asc</filename>) using a key already present in the
                original system. <filename>repodata/repomd.xml</filename> refers to other metadata
                file with their checksums. The most important file is
                    <filename>primary.xml</filename> which contains all package dependencies.</para>

            <para>If you have a directory with rpm packages, you can create the metadata for them
                using the <command>createrepo</command> tool. After that you can serve that
                repository via HTTP.</para>

            <para>If you have a directory with rpms you want to use as repository, you don’t need to
                add metadata. ZYpp allows to have a plain local directory as a repository, and will
                read the metadata directly from the rpm files into its cache.</para>

            <sect3 xml:id="sec-refresh-repo">
                <title>Refreshing a Repository</title>

                <para>You can refresh a repository with the command </para>
                <para>
                    <command>$ zypper ref</command>
                </para>

                <para>While the base repository of the distribution is normally immutable,
                    repositories like the one containing updates often get new content. The purpose
                    of refreshing a repository is to get the up-to-date version of the metadata
                    locally, so that all operations (solving, retrieval) match the current content
                    of the repository.</para>

                <para>If a repository is out of date, it means the local metadata represents a
                    previous version of the repository content. You could try to solve this and
                    fetch packages, but those packages may not exists on the repository anymore, and
                    you will get an error at retrieval time.</para>

                <para>The list of repositories of the system is kept in
                        <filename>/etc/zypp/repos.d</filename>. <command>zypper</command>
                    provides most of repository operations in a safer way than trying to update
                    these files manually.</para>

                <para>During refresh, metadata is cached locally at
                        <filename>/var/cache/zypp/raw</filename> and converted to an efficient
                    format for solving operations in <filename>/var/cache/zypp/solv</filename>. </para>

            </sect3>

            <sect3 xml:id="sec-services">
                <title>Services</title>

                <para>Services are a higher-level version of repositories. It is another index that
                    lists repositories. When the system is subscribed to a service, refreshing the
                    service will result in a new list of repositories, and the package manager will
                    add new ones or remove obsolete ones.</para>

                <para>Services are used for example on SUSE Linux Enterprise with the SUSE Customer
                    Center (SCC). A customer is subscribed to a service provided by SCC using proper
                    credentials. The customer, based on his or her entitlements, can “activate” a
                    new product. SUSE Customer Center knows about those activations, and on service
                    refresh, it will provide a new list of repositories that includes the new
                    activated product.</para>

                <para>Services can be installed remote (like SCC), or locally, via a plug-in, on the
                    system. The package manager asks the plug-in for a list of repositories. It is
                    up to the plug-in to build this list. This is normally used for integration with
                    other systems. For example, the connectivity between
                        <command>zypper</command> and Spacewalk respective SUSE Manager (see
                        <link xlink:href="https://www.suse.com/products/suse-manager/"/> was
                    originally implemented using a local plug-in.</para>

            </sect3>

            <sect3 xml:id="sec-repo-sources">
                <title>Repository sources</title>

                <para>If you are using SUSE Linux Enterprise, your repositories will appear after
                    the <command>SUSEConnect</command> tool registers your product against
                    the SUSE Customer Center at <link xlink:href="https://scc.suse.com/login"
                    />.</para>

                <para>If you are using openSUSE, the default installation will set up the base and
                    update the repositories. Additionally, there is a lot of content published by
                    the community on the build service projects or via projects like
                        <command>packman</command>packman (see <link
                        xlink:href="http://packman.links2linux.org/"/>.</para>

                <para>SUSE Linux Enterprise users can take advantage of the community content via
                    the Package Hub at <link xlink:href="https://packagehub.suse.com/"/>.</para>

            </sect3>
        </sect2>

        <sect2 xml:id="sec-pack-manager-operations">
            <title>Other Package Manager Operations</title>

            <para>You can use <command>zypper lu</command> to list updates, and <command>zypper
                    up</command> to install them.</para>

            <para>You can lock packages to avoid them being removed or pulled-in using
                    <command>zypper addlock</command> or <command> zypper removelock</command>. You
                can also list active locks with <command>zypper locks</command>.</para>

            <para>The distribution upgrade operation <command>dup</command> is used to do
                destructive upgrades. This means packages may be suggested for removal as
                dependencies like <command>Obsoletes</command> are taken into account. It is usually
                used to upgrade to major releases or to update rolling distributions like Tumbleweed
                (see <link xlink:href="https://en.opensuse.org/Portal:Tumbleweed"/>. This command
                needs to be used with care.</para>
        </sect2>

        <sect2 xml:id="sec-other-solvable-types">
            <title>Other Solvable Types (Products, Patterns, System)</title>

            <para>The package manager solver loads all available and installed packages and cares
                for solving the dependencies. However, there are other entities similar to packages
                that also have dependencies.</para>

            <sect3 xml:id="sec-patterns">
                <title>Patterns</title>

                <para>Patterns are used to install a collection of software in a comfortable way.
                    For example you can install a working Laptop-oriented system with the
                    command:</para>

                <screen>$ zypper install -t pattern laptop</screen>

                <para>But where do patterns come from? They do not exists on their own. The package
                    managers creates them dynamically from packages named patterns-XXXXXX which have
                    a special set of dependencies. Installing a pattern would actually install the
                    package representing that pattern. The other way around is true, if you install
                    the package representing the pattern, it will make the system look like the
                    pattern is installed.</para>

                <para>The command:</para>

                <screen>$ zypper info --provides patterns-openSUSE-laptop</screen>

                <para>reveals some detail behind patterns (equivalent to <command>rpm -q --provides
                        patterns-openSUSE-laptop</command>).</para>

            </sect3>

            <sect3 xml:id="sec-products">
                <title>Products</title>

                <para>Similar to patterns, products can be queried with:</para>

                <screen>$ zypper search -t product</screen>

                <para><quote>Product</quote> comes from a package called
                        <package>XXXXXX-release</package> which has some special dependencies
                        (<command>rpm -q --provides openSUSE-release</command>). The release
                    package/product installs some information in
                        <filename>/etc/products.d</filename> that is used by other tools get
                    information about the base and add-on products installed.</para>
            </sect3>

            <sect3 xml:id="sec-patches">
                <title>Patches</title>

                <para>Patches are used for updates and described by the
                        <filename>updateinfo.xml</filename> section of the metadata. They represent
                    an entity that conflicts with older versions of one or more packages. Installing
                    a patch does not install packages, but generates a conflict in the solver that
                    ends with the affected version of packages being upgraded.</para>

                <para>Patches also carry additional property, like the <emphasis role="strong"
                        >CVE</emphasis> (see <link xlink:href="https://cve.mitre.org/"/>identifiers
                    of the issues they fix or links to bug tracker incidents.</para>
            </sect3>

            <sect3 xml:id="sec-system">
                <title>System</title>
                <para>During solving, there is one entity providing dependencies that is used to
                    match locale and hardware information. If you have a Wi-Fi card, the package
                    manager will dynamically read <filename>/sys/devices</filename> and make this
                    entity have provides like: </para>
                <screen>Provides :modalias(pci:v0000104Cd0000840[01]sv*sd*bc*sc*i*)</screen>
                <para>A package providing a Wi-Fi driver for some cards (for example,
                        <package>wlan-kmp-default</package>), could have the following
                    dependencies:</para>

                <screen>Supplements: modalias(kernel-default:pci:v0000104Cd0000840[01]sv*sd*bc*sc*i*)
Supplements: modalias(kernel-default:pci:v0000104Cd00009066sv*sd*bc*sc*i*)
Supplements: modalias(kernel-default:pci:v000010B7d00006000sv*sd*bc*sc*i*)</screen>

                <para>This results in the fact that, at solving time, if the hardware is present,
                    the driver will be selected automatically.</para>

                <note>
                    <title>SUSE SolidDriver Program</title>
                    <para>This is one of the core features of the Kernel Module Packages (KMP)
                        section of the SUSE SolidDriver Program (see <link
                            xlink:href="https://drivers.suse.com/doc/SolidDriver/Kernel_Module_Packages.html"
                        />. For more information about the SUSE SolidDriver Program and about KMP's,
                        check the article <quote>Using SLES and the SLE SDK to Build a Kernel Module
                            Package (KMP)</quote> at <link
                            xlink:href="https://www.suse.com/communities/blog/using-sles-and-the-sle-sdk-build-kernel-module-package-kmp/"
                        />.</para>
                </note>

                <para>Something similar is done with translation packages and the current configured
                    system locale.</para>

                <important>
                    <title>All Information Comes from the Installed Packages</title>
                    <para>Be aware that all those types mentioned (Patterns, Products, System) are
                        only present at solving time. Actually your system consists only of
                        packages, and all information comes from the installed packages. Every
                        operation on patches, patterns and products result in a package operation.
                        The purpose behind is to make the package manager compatible with the lower
                        level <command>rpm</command> tool.</para>
                </important>
            </sect3>
        </sect2>
    </sect1>

    <sect1 xml:id="sec-creating-packages">
        <title>Creating packages</title>

        <para>When packages are created they provide a so called <filename>.spec</filename> file. A
            spec file defines the attributes of the package, explicit dependencies (others are
            injected as already mentioned), and how the content of the package is created. A very
            simple spec file would be:</para>

        <screen>Name:           mypackage
Version:        1.0
Release:        0
License:        MIT
Summary:        Dummy package
BuildRoot:      %{_tmppath}/%{name}-%{version}-build

%description
Dummy text

%install
mkdir -p %{buildroot}%{_datadir}/%{name}
touch %{buildroot}%{_datadir}/%{name}/CONTENT

%files
%defattr(-,root,root)
%{_datadir}/%{name}/CONTENT

%changelog</screen>

        <para>This spec file creates a directory <filename>/usr/share/mypackage</filename> and puts
            a dummy <filename>CONTENT</filename> file in it.</para>

        <para>spec files are heavily defined by macros that make sure that paths and values are
            specified by the distribution. Those macros are shipped by the base distribution and are
            located in <filename>/usr/lib/rpm</filename> and <filename>/etc/rpm</filename>. Other
            packages may contribute more macros. For example the macros defined in
                <filename>/usr/lib/rpm/golang-macros.rb</filename> are provided by the
                <package>golang-packaging</package> package and are useful to create packages that
            use the <emphasis role="strong">Go</emphasis> language.</para>

        <sect2 xml:id="sec-common-macros">
            <title>Common Macros</title>

            <para>When building spec files, you should be familiar with macros like <emphasis
                    role="strong">%{_prefix}</emphasis>, <emphasis role="strong"
                    >%{_datadir}</emphasis>, <emphasis role="strong">%{_mandir}</emphasis>,
                    <emphasis role="strong">%{_libdir}</emphasis>, <emphasis role="strong"
                    >%{_bindir}</emphasis>, etc... You can evaluate a macro as follows:</para>

            <screen>$ rpm --eval "%{_libdir}"
/usr/lib64</screen>
        </sect2>

        <sect2 xml:id="sec-sub-packages">
            <title>Sub-packages</title>

            <para>Sometimes you will build multiple components from a single source that are
                independent of each other.</para>

            <para>The sources for a package <package>Office Suite</package> may result in:</para>

            <itemizedlist>
                <listitem>
                    <para>A Word Processor</para>
                </listitem>
                <listitem>
                    <para>A Spreadsheet</para>
                </listitem>
                <listitem>
                    <para>Common libraries</para>
                </listitem>
                <listitem>
                    <para>Development files</para>
                </listitem>
            </itemizedlist>

            <para>For this, you can declare <package>subpackages</package>, independent description
                and attributes sections for each component. The build section is common to all
                subpackages, and then again in the <filename>%files</filename> section, you will
                declare which files go to each subpackage. In this example, the subpackages could
                be:</para>

            <itemizedlist>
                <listitem>
                    <para>
                        <package>office-wordprocessor</package>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <package>office-spreadsheet</package>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <package>liboffice</package>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <package>office-devel</package>
                    </para>
                </listitem>
            </itemizedlist>
        </sect2>

        <sect2 xml:id="sec-building-rpmbuild">
            <title>Building with rpmbuild</title>

            <para>You can build a package with the <command>rpmbuild</command> tool. It
                requires the spec file to be in a specific location. You can tweak the standard
                configuration to search spec files in the current directory:</para>

            <screen>$ cat ~/.rpmmacros
%topdir /space/packages
%_builddir %{topdir}/build
%_rpmdir %{topdir}/rpms
%_sourcedir %(echo $PWD)
%_specdir %(echo $PWD)
%_srcrpmdir %{topdir}/rpms</screen>

            <para>You can configure it so that built packages are saved in
                    <filename>/space/packages</filename>. Make the tweaks according to your own
                preferences.</para>

            <para>When this is set up, enter the following command:</para>

            <screen>$ rpmbuild -bb mypackage.spec
Executing(%install): /bin/sh -e /var/tmp/rpm-tmp.lVzwnj
+ umask 022
+ cd /space/packages/build
+ mkdir -p /home/duncan/rpmbuild/BUILDROOT/mypackage-1.0-0.x86_64/usr/share/mypackage
+ touch /home/duncan/rpmbuild/BUILDROOT/mypackage-1.0-0.x86_64/usr/share/mypackage/CONTENT
+ /usr/lib/rpm/brp-compress
+ /usr/lib/rpm/brp-suse
Processing files: mypackage-1.0-0.x86_64
Provides: mypackage = 1.0-0 mypackage(x86-64) = 1.0-0
Requires(rpmlib): rpmlib(CompressedFileNames) &lt;= 3.0.4-1 rpmlib(PayloadFilesHavePrefix) &lt;= 4.0-1
Checking for unpackaged file(s): /usr/lib/rpm/check-files /home/duncan/rpmbuild/BUILDROOT/mypackage-1.0-0.x86_64
Wrote: /space/packages/rpms/x86_64/mypackage-1.0-0.x86_64.rpm
Executing(%clean): /bin/sh -e /var/tmp/rpm-tmp.0xLGri
+ umask 022
+ cd /space/packages/build
+ /usr/bin/rm -rf /home/duncan/rpmbuild/BUILDROOT/mypackage-1.0-0.x86_64
+ rm -rf filelists</screen>

            <para>Now you can verify the content of the package:</para>

            <screen>% rpm -qpl /space/packages/rpms/x86_64/mypackage-1.0-0.x86_64.rpm
/usr/share/mypackage/CONTENT</screen>

            <para>Everything that you put into the <emphasis role="strong">%{buildroot}</emphasis>
                did end up as content of the package.</para>

            <para>The term <quote>building a package</quote> can have two meanings. One is
                assembling the package from existing content. You could build your application in
                Jenkins, take the built artifacts and use the spec file to package it.</para>

            <para>However, where <command>rpm</command> excels is that you can build the
                application in the spec file itself, and use the distribution and dependencies to
                set up the build environment.</para>

            <para>A common use case to illustrate this is the typical Linux application built with
                    <command> configure &amp;&amp; make &amp;&amp; make
                    install</command>. In the next example you build a package for gqlplus (see
                    <link xlink:href="http://gqlplus.sourceforge.net/"/>, an alternative client for
                Oracle databases.</para>

            <para>Provided that you have readline and ncurses development headers, you can build
                this application by unpacking the TAR archive and performing the commands mentioned
                above. Some programs require an extra step with <command>autoconf</command> to
                generate the <command>configure</command> script. This is specific to building
                software and has nothing to do with packaging.</para>

            <para>When you do <command>./configure</command> you need to pass the right
                    <command>--prefix</command>. Macros can help here. You could use the command
                    <command>configure --prefix=%{_prefix}</command>. However, there is a better
                macro called <emphasis role="strong">%configure</emphasis> which takes care and sets
                most of the configuration options (You can also try expanding it with <command>echo
                    $(rpm --eval '%configure')</command>).</para>

            <para>The package cannot build if some libraries are not present. A C compiler is there,
                but the basic build tools (<command>make</command>) are not available. That
                is what <emphasis role="strong">BuildRequires</emphasis> are for. They define what
                packages are needed for building - but not necessarily at runtime.</para>

            <para>On the other hand, the original <package>oracle-instantclient-sqlplus</package>
                package is required at runtime, but you do not need it to build your package.</para>

            <screen>Name:           gqlplus
Version:            1.15
Release:            0
License:            GPL-2.0
Summary:            A drop-in replacement for sqlplus, an Oracle SQL client
Url:                http://gqlplus.sourceforge.net/
Group:              Productivity/Databases/Clients
Source0:            %{name}-%{version}.tar.bz2
BuildRequires:  readline-devel
BuildRequires:  ncurses-devel
BuildRequires:  gcc make autoconf automake
BuildRoot:      %{_tmppath}/%{name}-%{version}-build
Requires:       oracle-instantclient-sqlplus
%description
GQLPlus is a drop-in replacement for sqlplus, an Oracle SQL client, for Unix and Unix-like platforms. The difference between GQLPlus and sqlplus is command-line editing and history, plus table-name and column-name completion.

%prep
%setup -q

%build
aclocal &amp;&amp; autoconf
automake --add-missing
%configure
make %{?_smp_mflags}

%install
%makeinstall

%files
%defattr(-,root,root)
%doc ChangeLog README LICENSE
%{_bindir}/gqlplus

%changelog</screen>

            <para>The <emphasis role="strong">Source0</emphasis> section specifies a source that you
                can refer later using the <emphasis role="strong">%SOURCE0</emphasis> or <emphasis
                    role="strong">%{S:0}</emphasis> macros. You can have more than one source
                    (<emphasis role="strong">Source1</emphasis>, etc).</para>

            <para>The <emphasis role="strong">prep</emphasis> section uses the <emphasis
                    role="strong">%setup</emphasis> macro (see <link
                    xlink:href="http://ftp.rpm.org/max-rpm/s1-rpm-inside-macros.html#S2-RPM-INSIDE-SETUP-MACRO"
                />to unpack the sources. You could as well operate directly on the source files if
                you need to do something unconventional. </para>

            <para>As we need <command>make install</command> to install the files inside <emphasis
                    role="strong">%{buildroot}</emphasis>, we should call <command>make install
                    DESTDIR=%{buildroot}</command>, but <emphasis role="strong"
                    >%makeinstall</emphasis> is a macro for that. </para>

            <para>The <emphasis role="strong">files</emphasis> section list the files
                    <package>rpmbuild</package> should expect to find inside the <emphasis
                    role="strong">%{buildroot}</emphasis> macro that will be the content of the
                package. </para>

            <note>
                <title>Not Needed at Runtime</title>
                <para>You do not need to add a runtime <emphasis role="strong">Requires</emphasis>
                    to the readline and ncurses libraries. Because the executable is linked against
                    the ones installed by the <package>-devel</package> packages, it will be scanned
                    and the right <emphasis role="strong">Requires</emphasis> will be
                    injected:</para>
            </note>

            <screen>$ rpm -qp --requires gqlplus-1.15-0.x86_64.rpm
libc.so.6()(64bit)
...
libncurses.so.6()(64bit)
libreadline.so.7()(64bit)
oracle-instantclient-sqlplus
...</screen>

            <para>These symbols are provided by the right package, thus the solver will match
                them:</para>

            <screen>rpm -q --whatprovides 'libncurses.so.6()(64bit)'
libncurses6-6.0-19.1.x86_64</screen>

            <para>For more information on how to build packages for various types of software, visit
                the <emphasis role="strong">openSUSE Packaging Guidelines</emphasis> at <link
                    xlink:href="https://en.opensuse.org/openSUSE:Packaging_guidelines"/>.</para>
        </sect2>

        <sect2 xml:id="sec-building-environment">
            <title>Building in a Real Build Environment</title>

            <para>Building this way means the build environment is your system. If a package is
                available in <emphasis role="strong">BuildRequires</emphasis>, you will have to
                install it on your system first.</para>

            <para>If the software you are building links against some library only if it is
                available, even if you do not mention it in your <emphasis role="strong"
                    >BuildRequires</emphasis>, if that library is present in your system, it will
                taint the build and make the command <command>configure</command> find it.</para>

            <para> The following section outlines what to do if you want to build against only the
                packages that are in the build requirements.</para>

            <sect3 xml:id="sec-open-build-service">
                <title>The Open Build Service</title>

                <para>The <emphasis role="strong">Open Build Service </emphasis> at <link
                        xlink:href="http://openbuildservice.org/"/> allows to build packages for
                    multiple distributions and architectures. Visit the <emphasis role="strong"
                        >Materials</emphasis> section of the Web site (see <link
                            xlink:href="http://openbuildservice.org/help/"/>) for a deeper
                    introduction. For the package you are building, you can get an account at the
                        <emphasis role="strong">openSUSE Build Service</emphasis> instance. Go to
                    your <quote>Home Project</quote>, and click <quote>Create New Package</quote>.
                    Upload the spec file and sources. </para>
                <para>After that you need to configure some target distributions for your home
                    project. That can be one base distribution, or another project. This shows the
                    power by allowing building based on layers that can override things from
                    previous layers. </para>
                <para>Add the most popular (open)SUSE distributions (latest Leap and Tumbleweed) and
                    your package will be built automatically. A repository will be published
                    automatically and made available for public consumption. </para>
                <para>Every time the sources change, the package will be rebuilt. If you have more
                    packages in the same project, those will be rebuilt in the right order, and
                    re-published. </para>

                <figure xml:id="fig-rpm-packaging-obs">
                    <title>Open Build Service Overview of Packages</title>
                    <mediaobject>
                        <imageobject role="fo">
                            <imagedata fileref="rpm-packaging-gqlplus-obs.png" width="90%"
                                format="PNG"/>
                        </imageobject>
                        <imageobject role="html">
                            <imagedata fileref="rpm-packaging-gqlplus-obs.png" width="90%"
                                format="PNG"/>
                        </imageobject>
                    </mediaobject>
                </figure>

                <para>The Open Build Service cannot only build packages, but also images from those
                    packages. All SUSE products and the openSUSE distributions are built using the
                    Open Build Service. Contributors submit new sources, and the Open Build Service
                    takes care of assembling everything (and openQA later ensures that everything
                    works).</para>

            </sect3>

            <sect3 xml:id="sec-using-obs-locally">
                <title>Using the Open Build Service locally</title>

                <para>With the <command>osc</command> tool you can checkout packages from
                    the Open Build Service, make changes to them and resubmit them.</para>

                <screen>$ osc co home:dmacvicar gqlplus
A    home:dmacvicar
A    home:dmacvicar/gqlplus
A    home:dmacvicar/gqlplus/gqlplus-1.15.tar.bz2
A    home:dmacvicar/gqlplus/gqlplus.changes
A    home:dmacvicar/gqlplus/gqlplus.spec
At revision 4.</screen>

                <para>The most interesting feature is the ability to build packages or images
                    locally. osc allows you to build in an isolated environment (either a chroot
                    jail [see <link xlink:href="https://en.wikipedia.org/wiki/Chroot"/>] or a
                    virtual machine) by setting up that environment automatically using the
                        <emphasis role="strong">BuildRequires</emphasis> of the spec file. It also
                    allows you to build against a different distribution than the one you are
                    running.</para>

                <screen>$ cd home:dmacvicar/gqlplus
$ osc build openSUSE_Leap_42.2
...</screen>
            </sect3>
        </sect2>

        <sect2 xml:id="sec-improving-package">
            <title>Improving the Package</title>

            <para>When you build a package in the Open Build Service, you will find out that, in
                addition to the automated actions that inject dependencies, there are several checks
                being done to the package. </para>
            <para>These checks are very detailed. But this is the only way to ensure quality and
                consistency when a product is assembled from thousands of sources by hundreds of
                contributors. </para>
            <para>The <command>spec-cleaner</command> tool can help you keeping your spec
                file in shape: </para>

            <screen>$ spec-cleaner -i gqlplus.spec</screen>

            <para>For example, it can help you converting <emphasis role="strong">BuildRequires:
                    foo-devel</emphasis> dependencies to <emphasis role="strong">BuildRequires:
                    pkgconfig(foo)</emphasis>. If a <package>-devel</package> package installs a
                    <package>pkg-config</package> module, a <emphasis role="strong">Provides:
                    pkgconfig(foo)</emphasis> is automatically injected. If the build process
                    (<command>./configure</command> or <command>Makefile</command>) uses
                    <command>pkg-config</command> to find the software, it makes more sense and it
                is closer to reality to depend on <package>pkgconfig(foo)</package> being present,
                regardless which <package>-devel</package> package provides it. </para>

            <para>You can get more information about how to fix post-build checks in the openSUSE
                Packaging Checks page at <link
                    xlink:href="https://en.opensuse.org/openSUSE:Packaging_checks"/>. </para>

        </sect2>

        <sect2 xml:id="sec-changelogs">
            <title>Changelogs</title>

            <para>Until now you left the <emphasis role="strong">%changelog</emphasis> section
                empty. Some distributions write the history of the package to the changelog.
                SUSE-flavored distributions keep the changelog in a separate
                    <filename>.changes</filename> file. To quickly generate or update it, you can
                use <command>osc vc</command> in the directory containing the spec file and the
                sources.</para>

        </sect2>

    </sect1>

    
    <?pdfpagebreak style="sbp" formatter="fop"?>
    
    <xi:include href="sbp-legal-notice.xml"/>
    
    <?pdfpagebreak style="sbp" formatter="fop"?>
    <xi:include href="license-gfdl.xml"/>
</article>
