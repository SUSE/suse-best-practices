:docinfo:

:sles: SUSE Linux Enterprise Server
:slem: SUSE Linux Enterprise Micro
:slem_version: 5.4
:sles_version: 15 SP5
:lh: Longhorn
:rancher: Rancher Prime
:harvester: Harvester
:rke: Rancher Kubernetes Engine 2
:eic: SAP Edge Integration Cell
:elm: SAP Edge Lifecycle Management
:rac: Rancher Application Collection
:redis: Redis
:sis: SAP Integration Suite


// TODO
// How many nodes?
// What Hardware?
// Describe SELinux

= {eic} on SUSE

== Introduction

This guide describes the installation of {eic} on {rke} using {rancher}.
It will guide you through the steps of:

* Installing {rancher}
* Setup {rke} clusters
* Deploy mandatory components for {eic}
* Deploying {eic} into your {rke}

== Preparations

* Get subscriptions for:
** SLE Micro
** {rancher}
** {lh}

* Check the storage requirements.

* Create a or get access to a private container registry.

* Get an SAP S-user to access software and documentation by SAP.

* Read the relevant SAP documentation:

** https://me.sap.com/notes/3247839[Release Note for SAP Edge Integration Cell]

** https://me.sap.com/notes/2946788[Release Note for SAP ELM Bridge]  

** https://help.sap.com/docs/integration-suite/sap-integration-suite/setting-up-and-managing-edge-integration-cell[Installation Guide at help.sap.com]  


== Installing {slem} {slem_version}
There are several ways to install {slem} {slem_version} we will use in our Best Practice Guide the Self Install Image with the Combustion and Ignition function.

include::SAP-EIC-SLEMicro.adoc[SLEMicro]

++++
<?pdfpagebreak?>
++++

//TODO check dependencies of other doc files to adjust header hierarchy
include::SAPDI3-Rancher.adoc[Rancher]

++++
<?pdfpagebreak?>
++++

include::SAP-Rancher-RKE2-Installation.adoc[]

++++
<?pdfpagebreak?>
++++

== Install MetalLB Loadbalancer

include::SAP-EIC-Metallb.adoc[Metallb]
++++
<?pdfpagebreak?>
++++

== Installing Redis

// https://help.sap.com/docs/integration-suite/sap-integration-suite/prepare-your-kubernetes-cluster#redis-data-store-requirements

Before deploying Redis, make sure that the requirements described in
https://me.sap.com/notes/3247839
are met.

Furthermore make sure to get an understanding of what grade of persistence you want to achieve for your {redis} cluster.
To get more information about persistence in {redis}, have a look at
https://redis.io/docs/management/persistence/ .


include::SAP-EIC-Redis.adoc[]

++++
<?pdfpagebreak?>
++++

== Installing {eic}

include::SAP-EIC.adoc[]

++++
<?pdfpagebreak?>
++++

== Appendix

=== Using self signed certificates

In this chapter we will explain how to create self signed certificates and how to make them available within Kubernetes.

==== Create the self signed certificates

CAUTION: It is discouraged to use self signed certifcates for production environments.

As a first step, you need to create a certificate authority (further called CA) with its key and certificate.
In the excerpt below you can find an example how create such with a passpharse of your choice:
----
$ openssl req -x509 -sha256 -days 1825 -newkey rsa:2048 -keyout rootCA.key -out rootCA.crt -passout pass:<ca-passphrase> -subj "/C=DE/ST=BW/L=Nuremberg/O=SUSE"
----

This gives you the *rootCA.key* and the *rootCA.crt*.
For the server certificate, a certificate signing request (further called CSR) is needed.
The given excerpt show how to create such a CSR:
----
$ openssl req -newkey rsa:2048 -keyout domain.key -out domain.csr -passout pass:<csr-passphrase> -subj  "/C=DE/ST=BW/L=Nuremberg/O=SUSE"
----

Before you can sing the CSR, you'll need to add the DNS names of your Kuberntes Services to the CSR.
Therefore create a file with the content below and replace the *<servicename>* and *<namespace>* with the name of your Kubernetes service and the namespace this is placed in:
 
----
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
subjectAltName = @alt_names
[alt_names]
DNS.1 = <servicename>.<namespace>.svc.cluster.local
DNS.2 = <AltService>.<AltNamespace>.svc.cluster.local
----

You can now use the previously created rootCA.key and rootCA.crt with the extension file to sign the CSR.
The example below shows how to do that by passing the extension file (here named *domain.ext*):
----
$ openssl x509 -req -CA rootCA.crt -CAkey rootCA.key -in domain.csr -out server.pem -days 365 -CAcreateserial -extfile domain.ext -passin pass:<ca-passphrase>
----

This creates a file called *server.pem* which is your certificate to be used for your application.


Your *domain.key* is at this point still encrypted, but the application will need an uncrypted server key.
To decrypt, run the given command, which will create the *server.key*
----
$ openssl rsa -passin pass:<csr-passphrase> -in domain.key -out server.key
----

Some applications (like Redis) require a full certificate chain to operate.
To get a full certificate chain, concat the generated *server.pem* with the *rooCA.crt* like below:

----
$ cat server.pem rootCA.crt > chained.pem
----

Afterwards you should have the files called server.pem, server.key and chained.pem which can be used for your applications like Redis or PostgresSQL.


==== Upload certificates to Kubernetes

To use certificate files in Kubernetes, you need to store them as so called *secrets*.
An example how to upload your certificates to Kubernetes is shown in the given excerpt:
 
----
$ kubectl -n <namespace> create secret generic <certName> --from-file=./root.pem --from-file=./server.pem --from-file=./server.key
----

NOTE: Most applications are expecting to have the secret to be used in the same namespace as the application.


++++
<?pdfpagebreak?>
++++

:leveloffset: 0
// Standard SUSE Best Practices includes
== Legal notice
include::common_sbp_legal_notice.adoc[]

++++
<?pdfpagebreak?>
++++

// Standard SUSE Best Practices includes
:leveloffset: 0
include::common_gfdl1.2_i.adoc[]
