<?xml version="1.0" encoding="UTF-8"?>
<!--<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng" type="xml"?>-->
<!DOCTYPE article [
<!ENTITY % entity SYSTEM "entity-decl.ent">
%entity;
]>

<article role="sbp" xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xmlns:its="http://www.w3.org/2005/11/its"
  xml:id="art-sbp-pydantic" xml:lang="en">


  <info>
    <title>Introduction to the Python Library Pydantic</title>

    <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
      <dm:bugtracker>
        <dm:url>https://github.com/SUSE/suse-best-practices/issues/new</dm:url>
        <dm:product>Introduction to Pydantic</dm:product>
      </dm:bugtracker>
      <dm:editurl>https://github.com/SUSE/suse-best-practices/blob/master/xml/</dm:editurl>
    </dm:docmanager>

     <meta name="series" its:translate="no">Best Practices</meta>
    <meta name="category" its:translate="no">
      <phrase>Development Tools</phrase>
    </meta>
    <meta name="task" its:translate="no">
      <phrase>Implementation</phrase>
    </meta>
    <meta name="title" its:translate="yes">Introduction to Pydantic</meta>
    <meta name="description" its:translate="no">Get an overview of the Python data validation library Pydantic 
      and its most important features</meta>
    <meta name="social-descr" its:translate="yes">Intro to Pydantic</meta>
<!--    <meta name="productname" its:translate="no">
      <productname version=""></productname>
    </meta>-->
    
    <meta name="platform" its:translate="no">Pydantic</meta>
    <meta name="platform" its:translate="no">Python</meta>


    <authorgroup>
      <author>
        <personname>
          <firstname>Sushant</firstname>
          <surname>Gaurav</surname>
        </personname>
        <affiliation>
          <jobtitle>Technical Writer</jobtitle>
          <orgname>SUSE</orgname>
        </affiliation>
      </author>


      <!--   <editor>
        <orgname></orgname>
        </editor>
        <othercredit>
        <orgname></orgname>
        </othercredit>-->
    </authorgroup>

    <cover role="logos">
      <mediaobject>
        <imageobject role="fo">
          <imagedata fileref="suse.svg" width="5em" align="center" valign="bottom"/>
        </imageobject>
        <imageobject role="html">
          <imagedata fileref="suse.svg" width="152px" align="center" valign="bottom"/>
        </imageobject>
        <textobject>
          <phrase>SUSE logo</phrase>
        </textobject>
      </mediaobject>
    </cover>

    <revhistory xml:id="rh-art-pydantic">
      <revision>
        <date>2025-09-23</date>
        <revdescription>
          <para> </para>
        </revdescription>
      </revision>
    </revhistory>

<abstract>
  <para>This document provides an introduction to Pydantic, a powerful Python library designed for
    data validation and settings management, and details its most important features.</para>
  
  <para>
    <emphasis role="strong">Disclaimer: </emphasis> Documents published as part of the SUSE Best
    Practices series have been contributed voluntarily by SUSE employees and third parties. They are
    meant to serve as examples of how particular actions can be performed. They have been compiled
    with utmost attention to detail. However, this does not guarantee complete accuracy. SUSE cannot
    verify that actions described in these documents do what is claimed or whether actions described
    have unintended consequences. SUSE LLC, its affiliates, the authors, and the translators may not
    be held liable for possible errors or the consequences thereof. 
  </para>
</abstract>
  

  </info>


  <sect1 xml:id="sec-intro">
    <title>Introduction</title>

    <para>Data exchange is a fundamental part of modern applications, especially those that interact
      with APIs, databases, or external services. In <link xlink:href="https://docs.python.org/3/">Python</link>, ensuring
      data is structured, validated, and easily converted between formats is critical. This is where
      Pydantic comes into the picture.</para>

    <para><link xlink:href="https://docs.pydantic.dev/latest/">Pydantic</link>is a powerful Python library designed for
      data validation and settings management. It uses Python type hints to define, parse, and
      enforce strict typing on  <link xlink:href="https://docs.pydantic.dev/latest/concepts/models/">data models</link>
      making it easier to work with structured and semi-structured data.</para>

    <para>Whether you are handling user input, API responses, or configuration files, Pydantic
      ensures your application receives data in the correct format. If the data does not match the
      defined schema, Pydantic raises clear and informative validation errors. This helps reduce the
      debugging time and improves code reliability.</para>

    <para>This document is intended to provide an initial introduction and overview of Pydantic. The
      following sections cover the most important functions and features of Pydantic. However, the
      document does not claim to be exhaustive.</para>
    
    <sect2>
      <title>Pydantic v1 vs. Pydantic v2: What changed?</title>
      
      <para>Pydantic v2 represents a major upgrade over v1, offering improved performance,
        enhanced type safety, cleaner validation syntax, and better serialization tools. 
        Although many v1 models will still work with v2, some <link xlink:href="https://docs.pydantic.dev/latest/migration/">migration steps</link>
        are required due to changes in decorators and method names.</para>
      
      <para><emphasis role="strong">Key Differences at a Glance:</emphasis></para>
      
      <table>
        <title>Comparison: Pydantic v1 vs. Pydantic v2</title>
        <tgroup cols="3">
          <colspec colname="col_1" colwidth="33*"/>
          <colspec colname="col_2" colwidth="33*"/>
          <colspec colname="col_3" colwidth="33*"/>
          <thead>
            <row>
              <entry>Feature</entry>
              <entry>Pydantic v1</entry>
              <entry>Pydantic v2</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>Validation engine</para>
              </entry>
              <entry>
                <para>Pure Python</para>
              </entry>
              <entry>
                <para>Rust-based core (faster)</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Field validators</para>
              </entry>
              <entry>
                <para><parameter>@validator</parameter></para>
              </entry>
              <entry>
                <para><parameter>@field_validator</parameter></para>
              </entry> 
            </row>
            <row>
              <entry>
                <para>Model validators</para>
              </entry>
              <entry>
                <para><parameter>@root_validator</parameter></para>
              </entry>
              <entry>
                <para><parameter>@model_validator</parameter></para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Computed fields</para>
              </entry>
              <entry>
                <para>Via<parameter>@property</parameter></para>
              </entry>
              <entry>
                <para>Native via <parameter>@computed_field</parameter></para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Type system</para>
              </entry>
              <entry>
                <para>Standard type hints</para>
              </entry>
              <entry>
                <para>Better support for advanced typing</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Strict type handling</para>
              </entry>
              <entry>
                <para>Limited</para>
              </entry>
              <entry>
                <para>Enhanced (<parameter>StrictStr</parameter>, <parameter>StrictInt</parameter>, etc.)</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Serialization</para>
              </entry>
              <entry>
                <para><command>.dict()</command>, <command>.json()</command></para>
              </entry>
              <entry>
                <para><command>_dump()</command>, <command>_dump_json()</command></para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Environment settings</para>
              </entry>
              <entry>
                <para><parameter>BaseSettings</parameter></para>
              </entry>
              <entry>
                <para>Improved support for config and env parsing</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Error reporting</para>
              </entry>
              <entry>
                <para>Simple</para>
              </entry>
              <entry>
                <para>More structured and user-friendly</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      
    </sect2>
    
    <sect2 xml:id="sec-major-improvements-pydanticv2">
      <title>Major improvements in Pydantic v2</title>
      
      <para><emphasis role="strong">Improved Validation Flow</emphasis></para>
      <para>The introduction of <parameter>before</parameter> and <parameter>after</parameter> 
        modes for both field and model validators gives developers precise control over the validation lifecycle. 
        This enables early rejection of bad data or sophisticated cross-field logic as needed.</para>
      
      <para><emphasis role="strong">Enhanced Serialization</emphasis></para>
      <para>Pydantic v2’s <command>.model_dump() </command>and <command>.model_dump_json()</command> 
        provide a more flexible and consistent serialization API, especially when dealing with computed fields or nested models.</para>
      
    </sect2>
  </sect1>

  <sect1 xml:id="sec-basemodel">

    <title>The role of <classname>BaseModel</classname></title>
    <para/>
    <para>The core of Pydantic is the <link
        xlink:href="https://docs.pydantic.dev/latest/api/base_model/">
        <classname>BaseModel</classname>
      </link> class. Every custom model in Pydantic is built by inheriting this base class. It
      provides essential functionality, including:</para>

    <itemizedlist>
      <listitem>
        <para>Field definition and type enforcement</para>
      </listitem>
      <listitem>
        <para>Built-in validation and error messaging</para>
      </listitem>
      <listitem>
        <para>Data serialization and deserialization</para>
      </listitem>
      <listitem>
        <para>Automatic type conversion when possible</para>
      </listitem>
    </itemizedlist>

    <para/>
    <para>By extending <classname>BaseModel</classname>, you gain access to a robust set of tools that ensure your data
      conforms to the expected types and structures.</para>
    <para/>
    <para>Example (Product class inherits <classname>BaseModel</classname> class):</para>

<screen>from pydantic import BaseModel
      
class Product(BaseModel):
price: int
</screen>
  

  <sect2 xml:id="sec-automatic-type-conversion">
    <title>Automatic type conversion</title>

    <para>One of the most useful features of Pydantic is its ability to perform type coercion
      automatically. When <emphasis>possible</emphasis>, Pydantic converts input data to match the
      declared type.</para>

    <para>Example:</para>

<screen>python
from pydantic import BaseModel

class Product(BaseModel):
   price: int

Product(price='99')       # Allowed: '99' is converted to 99
Product(price='99a')      # Raises ValidationError: cannot convert to int
</screen>

    <para>Error:</para>

<screen>Product(price='99a')      # Raises ValidationError: cannot convert to int
 File "/Users/imsushant/Library/Python/3.9/lib/python/site-packages/pydantic/main.py", line 253, in __init__
   validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)
pydantic_core._pydantic_core.ValidationError: 1 validation error for Product
price
 Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='99a', input_type=str]
   For further information visit https://errors.pydantic.dev/2.11/v/int_parsing
</screen>

    <para>In this example, a string containing numeric characters (<code>'99'</code>) is accepted
      and converted to an integer, while an invalid string (<code>'99a'</code>) results in a
      validation error.</para>

  </sect2>

  <sect2 xml:id="sec-real-world-example">
    <title>Real-world example (Parsing JSON)</title>

    <para>Consider a scenario where your application receives JSON data from an external API:</para>

<screen>{
 "id": "101",
 "name": "Sam",
 "salary": "12000"
}
</screen>

    <para>You can use Pydantic to model and validate this data:</para>

<screen>from pydantic import BaseModel

class Employee(BaseModel):
   id: int
   name: str
   salary: float

emp = Employee(**json_data)
print(emp)
# Employee(id=101, name='Sam', salary=12000.0)
</screen>

    <note><title>Automatic conversion</title>
      <para>Even though the <computeroutput>id</computeroutput> and 
        <computeroutput>salary</computeroutput> fields arrive as strings, Pydantic
      automatically converts them to the appropriate numeric types. </para>
    <para>If you do not want or like the automatic conversion, Pydantic allows to enable the strict
      feature. Read more in <xref linkend="sec-enforcing-strict-types"/>.</para>
      </note>

    <para>In the above example, the <function>**</function> operator is unpacking the <package>json_data</package>
    dictionary into keyword arguments.</para>
  </sect2>

  </sect1>

  <sect1 xml:id="sec-understanding-field-function">
    <title>Understanding <function>Field</function> function </title>

    <para>In Pydantic, <link xlink:href="https://docs.pydantic.dev/latest/api/fields/">
        <function>Field</function>
      </link> is used to configure individual model attributes. It allows you to define default
      values, add validation constraints, and provide metadata such as titles, descriptions, or
      example values. </para>

    <para>It is not mandatory but using <function>Field</function> helps improve clarity, maintainability, and control
      over model behavior.</para>
    <para/>
    <para>The key use cases for <function>Field</function> include:</para>

<itemizedlist>
  <listitem>
    <para>Defining default values</para>
    </listitem>
  <listitem>
    <para>Setting validation constraints (such as minimum or maximum length)</para>
    </listitem>
  <listitem>
    <para>Adding metadata (like descriptions or usage examples)</para>
    </listitem>
  <listitem>
    <para>Customizing serialization or documentation behavior</para>
  </listitem>
</itemizedlist>   
    
    <para/>
    <para>The common parameters used with <function>Field</function> include:</para>
 
 <itemizedlist>
   <listitem>
     <para><parameter>default</parameter>, <parameter>title</parameter>, 
       <parameter>description</parameter>, <parameter>examples</parameter></para>
    </listitem>
   <listitem>
     <para><parameter>min_length</parameter>, <parameter>max_length</parameter>, 
       <parameter>regex</parameter></para>
    </listitem>
   <listitem>
     <para><parameter>ge</parameter> (greater than or equal to), <parameter>le</parameter> 
       (less than or equal to)</para>
    </listitem>
   <listitem>
     <para><parameter>strict</parameter>, <parameter>frozen</parameter>, and others</para>
   </listitem>
 </itemizedlist>   
    
    <para>Example:</para>

<screen>from pydantic import BaseModel, Field, PositiveInt

class User(BaseModel):
   id: int
   name: str = Field(min_length=3)
   age: PositiveInt = Field(default=18)
</screen>

    <para>Here, <parameter>name</parameter> must be at least three characters long, and 
      <parameter>age</parameter> must be non-negative, with a default value of 18. </para>

<note>
  <title>Keep in mind:</title>
<itemizedlist>
  <listitem>
    <para>To mark a field as optional, wrap the type with <parameter>Optional[...]</parameter>.</para>
  </listitem>
  <listitem>
    <para>Use <parameter>...</parameter> (Ellipsis) to mark a field as required when no default is
    provided.</para>
  </listitem>
  <listitem>
    <para><parameter>PositiveInt</parameter> is a Pydantic type that automatically enforces the constraint
      that the integer must be positive.</para>
    <para/>
  </listitem>
</itemizedlist>
</note>

    <sect2 xml:id="sec-enforcing-strict-types">
      <title>Enforcing strict types with <parameter>Field(strict=True)</parameter></title>

      <para>By default, Pydantic tries to coerce values into the expected type. This behavior is
        helpful in many situations. But, in some scenarios, you may need stricter validation for
        sensitive or critical fields. For such scenarios, use <parameter>strict=True</parameter> to enforce exact type
        matching:</para>

      <para><emphasis role="strong">Example:</emphasis></para>

<screen>from pydantic import BaseModel, Field

class User(BaseModel):
   age: int = Field(strict=True)

User(age="21")  # Raises validation error: str is not int
</screen>
    </sect2>
  </sect1>

<sect1 xml:id="sec-using-annotated">
  <title>Using <function>Annotated</function> for cleaner type definitions</title>
 
  <para>The <function>Annotated</function> type was introduced in the 
    <package>typing</package> module to allow additional metadata to be
    attached to a type hint. Pydantic v2 adopts <function>Annotated</function> to define constraints, descriptions, and
    field-level metadata in a more structured and expressive way.</para>

  <para>Learn more about the <package>typing</package> module at <link xlink:href="https://docs.python.org/3/library/typing.html"></link>.</para>

  <para>Reasons to use <function>Annotated</function>:</para>
 
 <itemizedlist>
   <listitem>
  <para>Avoids mixing logic between type declaration and field definition</para>
   </listitem>
   <listitem>
  <para>Keeps the syntax cleaner and easier to read</para>
   </listitem>
   <listitem>
     <para>Enhances compatibility with tools like <link xlink:href="https://fastapi.tiangolo.com/"></link> <package>FastAPI</package>that
  generate documentation from model metadata</para>
   </listitem>
 </itemizedlist>
  
  <para><emphasis role="strong">Example: Classic <function>Field</function> usage without <function>Annotated</function></emphasis></para>

<screen>from pydantic import BaseModel, Field

class Patient(BaseModel):
   name: str = Field(
       title="Patient Name",
       description="It contains the name of the patient",
       examples=["Aman", "Suman"]
   )
</screen>

  <para><emphasis role="strong">Example: Modern usage with <function>Annotated</function></emphasis></para>

<screen>from typing import Annotated
from pydantic import BaseModel, Field

class Patient(BaseModel):
   name: Annotated[
       str,
       Field(
           title="Patient Name",
           description="It contains the name of the patient",
           examples=["Aman", "Suman"]
       )
   ]
</screen>

  <para><emphasis role="strong">Example: Combining constraints and metadata</emphasis></para>

  <para>This approach ensures clean definitions, enforces constraints, and provides rich metadata
    for tools and documentation.</para>

<screen>from typing import Annotated
from pydantic import BaseModel, Field

class Patient(BaseModel):
    name: Annotated[
       str,
       Field(
           title="Patient Name",
           description="It contains the name of the patient",
           min_length=2,
           examples=["Aman", "Suman"]
       )
   ]
   age: Annotated[
       int,
       Field(
           ge=0,
           description="Patient age (non-negative)"
       )
   ]
</screen>
  
</sect1>
 
 <sect1 xml:id="sec-what-are-validators">
   <title>Using validators and <function>ValidationError</function> in Pydantic</title>

   <para>Pydantic supports custom data validation through <link xlink:href="https://docs.pydantic.dev/latest/concepts/validators/"><emphasis role="strong">validators</emphasis></link>.
    Validators provide fine-grained control over how fields or models are validated, making them useful when the
    built-in validation logic is insufficient.</para>

  <para>Pydantic includes two primary types of validators:</para>
    <itemizedlist>
      <listitem>
        <para><link xlink:href="https://docs.pydantic.dev/latest/concepts/validators/#field-validators">field validators</link> and</para>
      </listitem>
      <listitem>
        <para><link xlink:href="https://docs.pydantic.dev/latest/concepts/validators/#model-validators">model validators</link></para>
      </listitem>
    </itemizedlist>


<sect2 xml:id="sec-field-validators">
  <title>Field validators</title>
  <para/>
  <para>Field-level validators allow you to define custom logic for individual fields. These
    validators are declared using the <parameter>@field_validator</parameter> decorator. 
    Introduced in Pydantic v2, this decorator must be used in
    combination with Python's standard <parameter>@classmethod</parameter> decorator.</para>

  <para><emphasis role="strong">Example:</emphasis></para>

<screen>from pydantic import BaseModel, field_validator

class User(BaseModel):
   username: str

   @field_validator("username")
   @classmethod
   def validate_username(cls, value):
       if " " in value:
          raise ValueError("Username must not contain spaces")
      return value
</screen>

  <para>In the above example:</para>
<itemizedlist>
  <listitem>
    <para><parameter>@classmethod</parameter> is applied first.</para>
  </listitem>
  <listitem>
    <para><parameter>field_validator</parameter> decorator contains the field name to validate.</para>
  </listitem>
  <listitem>
  <para><parameter>cls</parameter> refers to the model class (<parameter>User</parameter>).</para>
  </listitem>
  <listitem>
  <para><parameter>value</parameter> is the input provided for the <parameter>username</parameter> field.</para>
  </listitem>
</itemizedlist>
  
  <note>
    <title>Correct order of decorators</title>
    <para>The correct order of decorators is crucial. The <parameter>@classmethod</parameter> decorator
      must be applied before the <parameter>@field_validator</parameter> decorator, as Pydantic v2's <parameter>@field_validator</parameter>
    expects a class method (not a static method or instance method).</para>
  </note>
  
  <para>You can even apply a single validator to multiple fields. </para>

  <para><emphasis role="strong">Example</emphasis>:</para>

<screen>from pydantic import BaseModel, field_validator

class User(BaseModel):
   username: str
   email: str

   @field_validator("username", "email")
   @classmethod
   def no_spaces_allowed(cls, value, info):
       if " " in value:
           raise ValueError(f"{info.field_name} must not contain spaces")
       return value
</screen>
  
  <para>In the above example, the <function>no_spaces_allowed()</function> function is executed once per field, and the
    <parameter>info</parameter> parameter provides metadata such as the current field name.</para>
 
 <note>
   <title>Field validators</title>
  <para>Field validators execute before type coercion by default, which makes
    them ideal for validating raw input values.</para>
  <para/>
 </note>
    </sect2>
    
    <sect2 xml:id="sec-model-validators">
  <title>Model validators</title>
  <para/>
  <para>Model-level validators are methods used to validate the entire data model at once. They are
    useful for performing cross-field validation, where the validation of one field depends on the
    value of another, or for complex checks that involve multiple fields. In Pydantic v2, you use
    the <parameter>@model_validator</parameter> decorator for this purpose. This decorator replaces the earlier
    <parameter>@root_validator</parameter> from Pydantic v1.</para>
  
<screen>from pydantic import BaseModel, model_validator

class User(BaseModel):
   password: str
   confirm_password: str

   @model_validator(mode="after")
   def passwords_match(self):
       if self.password != self.confirm_password:
           raise ValueError("Passwords do not match")
       return self
</screen>

  <para>In the above example, <parameter>self</parameter> resembles the instance of the model.</para>
  <para/>
    </sect2>
    
    <sect2 xml:id="sec-validator-modes">
      <title>Validator modes (<parameter>before</parameter> and <parameter>after</parameter>)</title>

  <para>You can control when a validator runs using the <parameter>mode</parameter> argument:</para>
<itemizedlist>
  <listitem>
    <para><parameter>mode="before"</parameter> executes before standard Pydantic validation.</para>
  </listitem>
  <listitem>
    <para><parameter>mode="after"</parameter> executes after Pydantic validation and type coercion.</para>
  </listitem>
</itemizedlist>
      
      <table>
        <title>Validator types</title>
        <tgroup cols="3">
        <colspec colname="col_1" colwidth="33*"/>
        <colspec colname="col_2" colwidth="33*"/>
        <colspec colname="col_3" colwidth="33*"/>
        <thead>
          <row>
            <entry>Validator Type</entry>
            <entry><parameter>before</parameter> Mode</entry>
            <entry><parameter>after</parameter> Mode (Default)</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              <para>Field Validator </para>
            </entry>
            <entry>
              <para>Receives raw input</para>
            </entry>
            <entry>
              <para>Receives parsed and type-coerced value</para>
            </entry>
          </row>
          <row>
            <entry>
              <para>Model Validator </para>
            </entry>
            <entry>
              <para>Receives raw input dictionary</para>
            </entry>
            <entry>
              <para>Receives fully validated model instance</para>
            </entry> 
            </row>
        </tbody>
        </tgroup>
      </table>

      <para>In short, use <parameter>"before"</parameter> when you need to clean or reject invalid data early. 
        Use <parameter>"after"</parameter> for final checks, consistency validation, or business logic after all fields 
        have been validated.</para>
  <para/>
    </sect2>
    
    <sect2 xml:id="sec-differences-field-model-validator">
  <title>Key differences between field and model validator </title>

      <para>Although <parameter>@field_validator("username", "email")</parameter>` accepts multiple fields, 
        it still processes each field <emphasis role="strong">independently</emphasis>. 
        This means that the validator runs separately for each field, even if the logic is identical. 
        This approach can lead to redundant processing and is not ideal for validations that depend on multiple fields. 
        In such cases, using a <parameter>@model_validator</parameter> is more efficient and appropriate, 
        as it processes the entire model at once and allows for cross-field validation in a single pass.</para>

      <table>
        <title>Differences between Validator types</title>
        <tgroup cols="3">
          <colspec colname="col_1" colwidth="33*"/>
          <colspec colname="col_2" colwidth="33*"/>
          <colspec colname="col_3" colwidth="33*"/>
          <thead>
            <row>
              <entry>Aspect</entry>
              <entry>Field Validator</entry>
              <entry>Model Validator</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>Execution</para>
              </entry>
              <entry>
                <para>Per field</para>
              </entry>
              <entry>
                <para>Once per model instance</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Input </para>
              </entry>
              <entry>
                <para>Single field value (+ metadata)</para>
              </entry>
              <entry>
                <para>Entire model (either raw or parsed)</para>
              </entry> 
            </row>
            <row>
              <entry>
                <para>Use Case</para>
              </entry>
              <entry>
                <para>Field-level validation and transformation</para>
              </entry>
              <entry>
                <para>Cross-field validation, business logic</para>
              </entry> 
            </row>
          </tbody>
        </tgroup>
      </table>

    </sect2>    
   
    <sect2 xml:id="sec-handling-validation-errors">
  <title>Handling validation errors</title>
 
      <para>Whenever validation fails, Pydantic raises a 
        <link xlink:href="https://docs.pydantic.dev/latest/concepts/validators/#raising-validation-errors"><function>ValidationError</function></link>.
    This exception provides a detailed breakdown of the issue, including the field name, the error
    message, and the error type.</para>

  <para><emphasis role="strong">Example</emphasis>:</para>

<screen>from pydantic import BaseModel, ValidationError

class Product(BaseModel):
   price: float

try:
   Product(price="free")
except ValidationError as e:
   print(e)

# Output:
# 1 validation error for Product
# price
#   Input should be a valid number (type=type_error.float)
</screen>
      
      <para>To programmatically inspect errors, you can use <function>e.errors()</function> which returns a list of
  structured error dictionaries.</para>
    
  </sect2>
  
 </sect1>
  
  <sect1 xml:id="sec-dump-model-data-in-pydantic">
  <title>Dumping model data in Pydantic</title>

  <para>Pydantic models provide two helpful methods to extract data:</para>
<itemizedlist>
  <listitem>
    <para><link xlink:href="https://docs.pydantic.dev/latest/concepts/serialization/#modelmodel_dump"><command>.model_dump()</command></link>
      returns the model as a standard Python <filename>dict</filename>.</para>
  </listitem>
  <listitem>
    <para><link xlink:href="https://docs.pydantic.dev/latest/concepts/serialization/#modelmodel_dump_json"><command>.model_dump_json()</command></link>
         returns the model data as a JSON string.</para>
  </listitem>
</itemizedlist>

  <para>These methods are commonly used when serializing models for storage, logging, or API
    responses.</para>

    <para><emphasis role="strong">Example:</emphasis></para>

<screen>from pydantic import BaseModel

class User(BaseModel):
   name: str
   age: int

user = User(name="Sam", age=25)

# model_dump() returns a Python dictionary
dumped_user = user.model_dump()

print(dumped_user)
# Output: {'name': 'Sam', 'age': 25}

print(type(dumped_user))
# Output: &lt;class 'dict'&gt;

# model_dump_json() returns a JSON-formatted string
json_user = user.model_dump_json()

print(json_user)
# Output: {"name":"Sam","age":25}

print(type(json_user))
# Output: &lt;class 'str'&gt;
</screen>

<para>To learn about these methods in detail, check <xref linkend="sec-understanding-serialization"/>.</para>
    
  </sect1>
  
  <sect1 xml:id="sec-understanding-computed-fields">
  <title>Understanding computed fields in Pydantic</title>

  <para>In many applications, certain values are not provided directly by the user but are derived
    from other fields. These values are known as <link xlink:href="https://docs.pydantic.dev/2.0/usage/computed_fields/"><emphasis role="strong">computed fields</emphasis> </link>.</para>

    <para>Pydantic v2 provides support for computed fields through the 
      <parameter>@computed_field</parameter> decorator.
      This eliminates the need for workarounds, such as using <parameter>@property</parameter>, and provides better
      integration with Pydantics <link xlink:href="https://docs.pydantic.dev/latest/concepts/serialization/">Serialization</link>system.</para>
  
    <para><emphasis role="strong">Example:</emphasis></para>
  
<screen>from pydantic import BaseModel, computed_field
  
class Rectangle(BaseModel):
     width: float
     height: float
  
    @computed_field
    def area(self) -> float:
          return self.width * self.height
</screen>  
  
    <para>In the above example:</para>
  
  <itemizedlist>
    <listitem>
      <para>area is computed dynamically based on width and height.</para>
    </listitem>
    <listitem>
      <para>the <parameter>@computed_field</parameter> decorator registers the method as a virtual field.</para>
    </listitem>
  </itemizedlist>  
  
  <note>
    <title>Not included by default</title>
    <para>Computed fields are not included in serialized outputs by default, 
      preserving a clear boundary between user-provided input and derived values.</para>
  </note>
    
    <sect2 xml:id="sec-including-computed-fields">
      <title>Including Computed Fields in Output</title>
      
      <para>By default, computed fields are excluded from methods such as <command>.model_dump()</command>
        and <command>.model_dump_json()</command>. To include them, use the 
        <parameter>include_computed=True</parameter> argument:</para>
      
<screen>rect = Rectangle(width=10, height=5)
      print(rect.model_dump())
      # Output: {'width': 10, 'height': 5}
      
      print(rect.model_dump(include_computed=True))
      # Output: {'width': 10, 'height': 5, 'area': 50}
</screen>
      
      <para>This behavior is intentional as it ensures that:</para>
      
      <itemizedlist>
        <listitem>
          <para>computed values are not accidentally persisted or sent over APIs.</para>
        </listitem>
        <listitem>
          <para>only explicitly requested values are included.</para>
        </listitem>
        <listitem>
          <para>expensive calculations are avoided unless needed.</para>
        </listitem>
      </itemizedlist>
      
    </sect2>
  
  </sect1>
  
  <sect1 xml:id="sec-working-with-nested-models">
      <title>Working with nested models in Pydantic</title>
  
  <para>Pydantic supports nested models, enabling developers to represent structured, hierarchical
    data in a clean and intuitive way. This is particularly useful in applications that deal with
    complex schemas such as user profiles, blog posts, or nested comment threads (where one model
    depends on or contains another).</para>

  <para>Nested models in Pydantic allow you to:</para>

<itemizedlist>
  <listitem>
    <para>Represent relationships like <code>UserProfile -> Address -> Country</code></para>
  </listitem>  
  <listitem>
    <para>Encapsulate multi-level structured data (for example, <code>Blog -> Comment -> Author</code>)</para>
  </listitem>
  <listitem>
  <para>Validate recursive structures (for example, trees, chat threads)</para>
  </listitem>
</itemizedlist>

  <para>Pydantic offers three main types of nested model patterns, which are detailed in the next sections.</para>

<sect2 xml:id="sec-standard-nesting">
  <title>Standard nesting (referencing other models)</title>

  <para>The most common way to create nested data structures in Pydantic is through 
    <emphasis role="strong">composition</emphasis>.
    This involves referencing one Pydantic model inside another using type annotations. This
    approach allows you to build layered schemas, where a complex model is composed of simpler,
    reusable components, and it ensures each part is validated correctly.</para>

<screen>class Lesson(BaseModel):
   title: str
   content: str

class Module(BaseModel):
   name: str

   lessons: List[Lesson]  # Nested model: referencing Lesson inside Module
</screen>

  <para>This setup allows each <function>Module</function> to encapsulate a list of validated <function>Lesson</function> instances,
    promoting reusability and data consistency.</para>
  <para/>
</sect2>
  
  <sect2 xml:id="sec-self-referencing-models">
  <title>Self-referencing models (recursive structures)</title>
  <para/>
  <para>Pydantic also supports models that reference themselves. These are especially useful for
    representing recursive structures such as tree hierarchies or nested folders.</para>

<screen>class Node(BaseModel):
   name: str
   children: List['Node']  # Forward reference using a string

Node.model_rebuild()
</screen>

  <para>Because the class refers to itself and has not yet been fully constructed at the time of
    annotation, Pydantic requires <command>model_rebuild()</command> to resolve the forward reference. This ensures
    the <parameter>children</parameter> field is properly typed for validation and schema generation.</para>
  <para/>
  </sect2>
    
    <sect2 xml:id="sec-forward-referencing-multiple-models">
  <title>Forward referencing between multiple models</title>

      <para>For mutually dependent models where, for example, an <parameter>Employee</parameter> references 
        a <parameter>Manager</parameter>, and the <parameter>Manager</parameter> holds a list of
        <parameter>Employee</parameter> instances, Pydantic supports forward references using string annotations.</para>

<screen>class Employee(BaseModel):
   name: str
   manager: 'Manager' = None  # String-based forward reference

class Manager(BaseModel):
   name: str
   team: List[Employee] = []

# Resolve circular references
Employee.model_rebuild()
Manager.model_rebuild()
</screen>

      <para>Without <command>model_rebuild()</command>, these forward references would remain unresolved and lead to
    validation errors or incorrect schema generation.</para>
    </sect2>

<sect2 xml:id="sec-model-inheritance">
  <title>Model inheritance</title>

  <para>Pydantic models can also be extended using class inheritance, following standard Python
    principles. This pattern is useful for creating specialized models that share common fields and
    behavior with a parent model.</para>

  <para><emphasis role="strong">Example:</emphasis></para>

<screen>from pydantic import BaseModel

class Person(BaseModel):
   name: str
   age: int

class Worker(Person):
   company: str
   team: str

# Creating an instance of the derived model
worker = Worker(name="Alice", age=30, company="TechCorp", team="Engineering")

print(worker.model_dump())
# Output: {'name': 'Alice', 'age': 30, 'company': 'TechCorp', 'team': 'Engineering'}
</screen>

  <para>In this example, the <parameter>Worker</parameter> model inherits the <parameter>name</parameter>
    and <parameter>age</parameter> fields from the <parameter>Person</parameter> model and adds 
    its own unique fields, <parameter>company</parameter> and <parameter>team</parameter>. 
    This approach promotes code reuse and helps maintain consistency across related models.</para>

  <para>While inheritance is a powerful feature, Pydantic generally recommends using 
    <emphasis role="strong">composition</emphasis>
    (as seen in standard nesting) over inheritance in most cases. Composition typically leads to
    more flexible and loosely coupled code, which can be easier to maintain and extend in the long
    run.</para>
  <para/>
  
<sect3 xml:id="sec-why-model-rebuild-matters">
  <title>Importance of <command>model_rebuild()</command></title>
 
  <para>When forward references are used (either to the same model or another model that has not
    been defined yet), <command
      >model_rebuild()</command> is necessary to:</para>

<itemizedlist>
  <listitem>
  <para>re-evaluate type hints that were expressed as strings.</para>
  </listitem>
  <listitem>
  <para>replace string references with actual class objects.</para>
  </listitem>
  <listitem>
  <para>finalize model field definitions for accurate parsing and validation.</para>
  </listitem>
</itemizedlist>
 
  <para>This post-definition step allows Pydantic to maintain correctness in complex model
  structures.</para>
</sect3>
  </sect2>
  
  <sect2 xml:id="sec-example-nested-comment">
    <title>Example: Nested <function>Comment</function> model</title>
  <para/>
    <para>The following is an example of a nested <function>Comment</function> model as commonly 
      found in blog platforms. It incorporates all three nested model concepts:</para>

<itemizedlist>
  <listitem>
  <para>Referencing an <parameter>Author</parameter> model</para>
  </listitem>
  <listitem>
  <para>Self-referencing through nested replies</para>
  </listitem>
  <listitem>
  <para>Forward referencing using strings</para>
  </listitem>
</itemizedlist>
    
<screen>from pydantic import BaseModel
from typing import List, Optional

class Author(BaseModel):
   user_id: int
   username: str

class Comment(BaseModel):
   comment_id: int
   content: str
   author: Author  # Standard nesting
   replies: Optional[List['Comment']] = None  # Self-referencing

Comment.model_rebuild()

author1 = Author(user_id=1, username="Sam")

reply1 = Comment(
   comment_id=2,
   content="Replying to your comment!",
   author=author1
)

main_comment = Comment(
   comment_id=1,
   content="This is the main comment",
   author=author1,
   replies=[reply1]
)

print(main_comment.model_dump(indent=2))
</screen>

    <para><emphasis role="strong">Output</emphasis>:</para>

<screen>{
 "comment_id": 1,
 "content": "This is the main comment",
 "author": {
   "user_id": 1,
   "username": "Sam"
 },
 "replies": [
   {
     "comment_id": 2,
     "content": "Replying to your comment!",
     "author": {
       "user_id": 1,
       "username": "Sam"
     },
     "replies": null
   }
 ]
}
</screen>
    
  </sect2>

  </sect1>
  
  <sect1 xml:id="sec-understanding-serialization">
  <title>Understanding serialization in Pydantic</title>
  
    <para><link xlink:href="https://docs.pydantic.dev/latest/concepts/serialization/">Serialization</link> in Pydantic refers
    to the process of converting a model into a format suitable for storage or transmission. </para>

  <para>This typically means converting a model to a dictionary (<filename>dict</filename>dict) or 
    a JSON string (<filename>str</filename>). </para>

  <para>Pydantic also handles deserialization, which converts raw input data into structured model
    instances.</para>

  <para>Pydantic supports two key directions in serialization, which are detailed below.</para>

<sect2 xml:id="sec-up-serialization">
  <title>Up derialization (deserialization)</title>
  <para/>
  <para>Up serialization, also known as deserialization, is the process of converting raw data such
    as a dictionary or JSON object into a Pydantic model. This enables structured handling of
    unstructured input data.</para>

  <para><emphasis>Example:</emphasis></para>

<screen>data = {"name": "Sam", "joined": "2023-07-24T10:00:00"}
user = User(**data)  # Deserializes raw dict into a User model
</screen>
</sect2>
    
    <sect2 xml:id="sec-down-serialization">
  <title>Down serialization</title>
  <para/>
  <para>Down serialization refers to converting a Pydantic model into a format like a Python
    dictionary or a JSON string. This is typically used when the model data needs to be sent over a
    network, saved to a file, or logged.</para>
    </sect2>
    
    <sect2 xml:id="sec-serialization-methods">
      
  <title>Methods for serialization</title>

   <sect3 xml:id="sec-model-dump">
     <title><command>model_dump()</command></title>
  <para/>
     <para>The <command>model_dump()</command> method converts a Pydantic model into a standard Python dictionary It
       excludes computed fields by default unless <parameter>include_computed=True</parameter> is specified.It is best
    suited for internal Python logic, debugging, or when the data remains within the application.</para>
   </sect3>
      
   <sect3 xml:id="sec-model-dump-json">
     <title><command>model_dump_json()</command></title>

     <para>The <command>model_dump_json()</command> method returns a JSON-formatted string. 
       It automatically converts non-JSON-native types (such as <parameter>datetime</parameter> or 
       <parameter>Decimal</parameter>) into JSON-compatible representations, such as ISO 8601 strings. 
       It is ideal for API communication, file storage, or external logging.</para>
 
     <para><emphasis role="strong">Example with <parameter>datetime</parameter>:</emphasis>E</para>

<screen>from pydantic import BaseModel
from datetime import datetime

class User(BaseModel):
   name: str
   joined: datetime

# Up serialization: Create model from raw data
user = User(name="Sam", joined="2023-07-24T10:00:00")

# Down serialization: Convert to dictionary
print(user.model_dump())
# Output: {'name': 'Sam', 'joined': datetime.datetime(2023, 7, 24, 10, 0)}

# Down serialization: Convert to JSON string
print(user.model_dump_json())
# Output: {"name": "Sam", "joined": "2023-07-24T10:00:00"}
</screen>
     
   </sect3>
    </sect2>   
  
  </sect1>
  
  <sect1 xml:id="sec-faq">
  <title>FAQs</title>

<sect2 xml:id="sec-faq-one">
  <title>How does field aliasing affect serialization in Pydantic?</title>
  <para/>
  <para>Pydantic supports aliasing field names using the <parameter>alias</parameter> parameter in the <function>Field()</function>
    function. This is particularly useful when you need to conform to naming conventions, such as
    camelCase in API responses.</para>

<screen>from pydantic import BaseModel, Field

class User(BaseModel):
   full_name: str = Field(..., alias="fullName")

user = User(fullName="Sam")
print(user.model_dump(by_alias=True))  # {'fullName': 'Sam'}
</screen>

  <para>To ensure aliases are included in the serialized output, set <parameter>by_alias=True</parameter> when calling
    <command>model_dump()</command> or <command>model_dump_json()</command>.</para>
</sect2>
    
    <sect2 xml:id="sec-faq-two">
      <title>Are <command>model_dump()</command> and <command>model_dump_json()</command> 
        available in Pydantic v1?</title>

      <para>No. These methods are part of <emphasis role="strong">Pydantic v2</emphasis>. In Pydantic v1, serialization was handled
        using the <function>dict()</function> and <function>json()</function> methods.</para>
  <para/>
  <para>If you're upgrading from v1 to v2, note the following changes:</para>

<itemizedlist>
  
  <listitem>
    <para><command>model.dict()</command> <command>model.model_dump_json()</command></para>
  </listitem>
</itemizedlist>

    </sect2>
    
    <sect2 xml:id="sec-faq-three">
  <title>What happens if a field contains a non-serializable object during
    <command>model_dump_json()</command>?</title>

  <para>If a field contains a non-JSON-serializable object, such as a custom class or complex data
    type, <command>model_dump_json()</command> will raise a <computeroutput>TypeError</computeroutput>. 
    To handle this, you can either preprocess the data or define custom <parameter>json_encoders</parameter> 
    in your model's configuration.</para>

<screen>class Config:
   json_encoders = {
       CustomType: lambda v: str(v)
   }
</screen>
  </sect2>
    
    <sect2 xml:id="sec-faq-four">
      <title>Can I exclude certain fields when using <command>model_dump()</command> 
        or <command>model_dump_json()</command>?</title>

      <para>Yes. Both methods support parameters like <parameter>exclude</parameter>, 
        <parameter>include</parameter>, and <parameter>exclude_unset</parameter>.</para>

<screen>model.model_dump(exclude={"password"})</screen>

  <para>These options help you control exactly what gets serialized. It is useful when returning
    partial responses or removing sensitive data like passwords or tokens.</para>
    </sect2>
    
    <sect2 xml:id="sec-faq-five">
      <title>Is it possible to serialize nested models using <command>model_dump()</command> or
    <command>model_dump_json()</command>?</title>
  
  <para>Yes. Nested models are fully supported. When serialized, they are recursively converted to
    dictionaries or JSON strings.</para>
  
<screen>class Address(BaseModel):
    city: str

class User(BaseModel):
   name: str
   address: Address

user = User(name="Sushant", address=Address(city="Delhi"))
print(user_dump())
# {'name': 'Sushant', 'address': {'city': 'Delhi'}}
</screen>
  </sect2>
    
    <sect2 xml:id="sec-faq-six">
      <title>How to print compact or pretty-printed JSON output using <command>model_dump_json()</command>?</title>

      <para>By default, <command>model_dump_json()</command> produces compact JSON. 
        If you want pretty-printed (indented) output, you can pass formatting arguments using the <parameter>indent</parameter> parameter.</para>

<screen>user_dump_json(indent=2)</screen>

  </sect2>
    
  </sect1>
  
  
  <?pdfpagebreak style="sbp" formatter="fop"?>
  
  <xi:include href="sbp-legal-notice.xml"/>
  
  
  <?pdfpagebreak style="sbp" formatter="fop"?>
  <xi:include href="license-gfdl.xml"/>
  
</article>
